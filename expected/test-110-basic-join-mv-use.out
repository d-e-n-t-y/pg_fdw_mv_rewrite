explain (VERBOSE, COSTS OFF)
select n.name, n.class, v.additional, count(value) as count
FROM test_name n, test_value v
WHERE n.id1 = v.id1 and n.id2 = v.id2
GROUP BY n.name, n.class, v.additional;
                        QUERY PLAN                         
-----------------------------------------------------------
 HashAggregate
   Output: n.name, n.class, v.additional, count(v.value)
   Group Key: n.name, n.class, v.additional
   ->  Hash Join
         Output: n.name, n.class, v.additional, v.value
         Inner Unique: true
         Hash Cond: ((v.id1 = n.id1) AND (v.id2 = n.id2))
         ->  Seq Scan on public.test_value v
               Output: v.id1, v.id2, v.additional, v.value
         ->  Hash
               Output: n.name, n.class, n.id1, n.id2
               ->  Seq Scan on public.test_name n
                     Output: n.name, n.class, n.id1, n.id2
(13 rows)

-- FIXME: the above doesn't select the MV, most likely because the MV doesn't list the WHERE clause params in its tList, hence it is not possible for the vars to match up (when run with "server loopback options (add log_match_progress 'true')", it notes: "check_from_join_clauses_for_matview: expression not found in grouped rel: {OPEXPR :opno 1752 :opfuncid 1718 :opresulttype 16 :opretset false :opcollid 0 :inputcollid 0 :args ({VAR :varno 1 :varattno 1 :vartype 1700 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 1 :location 137} {VAR :varno 2 :varattno 1 :vartype 1700 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 2 :varoattno 1 :location 145}) :location 143}")'
--select n.name, n.class, v.additional, count(value) as count
--FROM test_name n, test_value v
--WHERE n.id1 = v.id1 and n.id2 = v.id2
--GROUP BY n.name, n.class, v.additional;

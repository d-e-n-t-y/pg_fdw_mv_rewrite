-- Anticipate message "MV contains a join of type not matched in query"
set mv_rewrite.log_match_progress = 'true';
explain (VERBOSE, COSTS OFF)
select n.name, n.class, v.additional, count(value) as count
FROM test_name n LEFT OUTER JOIN test_value v ON n.id1 = v.id1 and n.id2 = v.id2
GROUP BY n.name, n.class, v.additional;
INFO:  mv_rewrite_add_rewritten_mv_paths: evaluating MV: public.test_name_value_mv1
INFO:  mv_rewrite_check_group_clauses_for_mv: looking to rewrite JOIN, but MV is GROUP BY.
INFO:  mv_rewrite_add_rewritten_mv_paths: evaluating MV: public.test_name_value_mv1
INFO:  mv_rewrite_check_group_clauses_for_mv: looking to rewrite JOIN, but MV is GROUP BY.
INFO:  mv_rewrite_add_rewritten_mv_paths: evaluating MV: public.test_name_value_mv1
INFO:  mv_rewrite_join_node_is_valid_for_plan_recurse: MV contains a join of type not matched in query.
                        QUERY PLAN                         
-----------------------------------------------------------
 HashAggregate
   Output: n.name, n.class, v.additional, count(v.value)
   Group Key: n.name, n.class, v.additional
   ->  Hash Right Join
         Output: n.name, n.class, v.additional, v.value
         Inner Unique: true
         Hash Cond: ((v.id1 = n.id1) AND (v.id2 = n.id2))
         ->  Seq Scan on public.test_value v
               Output: v.id1, v.id2, v.additional, v.value
         ->  Hash
               Output: n.name, n.class, n.id1, n.id2
               ->  Seq Scan on public.test_name n
                     Output: n.name, n.class, n.id1, n.id2
(13 rows)

--select n.name, n.class, v.additional, count(value) as count
--FROM test_name n, test_value v
--WHERE n.id1 = v.id1 and n.id2 = v.id2
--GROUP BY n.name, n.class, v.additional;

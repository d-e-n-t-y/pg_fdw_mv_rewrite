-- alter server loopback options (add log_match_progress 'true');
explain verbose
select x.key, x.quantity
from (
    select key,
        case when count(value) < 10 then 'several'
            when count(value) < 100 then 'tens'
            when count(value) < 1000 then 'hundreds'
            when count(value) < 10000 then 'thousands'
            when count(value) < 100000 then 'tens of thousands'
            when count(value) < 1000000 then 'hundreds of thousands'
            when count(value) < 10000000 then 'millions'
            else 'many'
        end as quantity
    FROM test
    GROUP BY key
    union all
    select key, count(value)::text
    FROM test
    GROUP BY key
) x
order by x.key;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=182.23..187.43 rows=2080 width=64)
   Output: test.key, (CASE WHEN (count(test.value) < 10) THEN 'several'::text WHEN (count(test.value) < 100) THEN 'tens'::text WHEN (count(test.value) < 1000) THEN 'hundreds'::text WHEN (count(test.value) < 10000) THEN 'thousands'::text WHEN (count(test.value) < 100000) THEN 'tens of thousands'::text WHEN (count(test.value) < 1000000) THEN 'hundreds of thousands'::text WHEN (count(test.value) < 10000000) THEN 'millions'::text ELSE 'many'::text END)
   Sort Key: test.key
   ->  Append  (cost=0.00..67.60 rows=2080 width=64)
         ->  Custom Scan (MVRewriteScan)  (cost=0.00..18.80 rows=880 width=64)
               Output: test.key, (CASE WHEN (count(test.value) < 10) THEN 'several'::text WHEN (count(test.value) < 100) THEN 'tens'::text WHEN (count(test.value) < 1000) THEN 'hundreds'::text WHEN (count(test.value) < 10000) THEN 'thousands'::text WHEN (count(test.value) < 100000) THEN 'tens of thousands'::text WHEN (count(test.value) < 1000000) THEN 'hundreds of thousands'::text WHEN (count(test.value) < 10000000) THEN 'millions'::text ELSE 'many'::text END)
               Rewritten SQL: {QUERY :commandType 1 :querySource 0 :canSetTag false :utilityStmt <> :resultRelation 0 :hasAggs false :hasWindowFuncs false :hasTargetSRFs false :hasSubLinks false :hasDistinctOn false :hasRecursive false :hasModifyingCTE false :hasForUpdate false :hasRowSecurity false :cteList <> :rtable ({RTE :alias <> :eref {ALIAS :aliasname test_expr_mv1 :colnames ("key" "quantity")} :rtekind 0 :relid 16456 :relkind m :tablesample <> :lateral false :inh false :inFromCl true :requiredPerms 2 :checkAsUser 0 :selectedCols (b) :insertedCols (b) :updatedCols (b) :securityQuals <>}) :jointree {FROMEXPR :fromlist ({RANGETBLREF :rtindex 1}) :quals <>} :targetList ({TARGETENTRY :expr {VAR :varno 1 :varattno 1 :vartype 25 :vartypmod -1 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 1 :location -1} :resno 1 :resname <> :ressortgroupref 0 :resorigtbl 0 :resorigcol 0 :resjunk false} {TARGETENTRY :expr {VAR :varno 1 :varattno 2 :vartype 25 :vartypmod -1 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 2 :location -1} :resno 2 :resname <> :ressortgroupref 0 :resorigtbl 0 :resorigcol 0 :resjunk false}) :override 0 :onConflict <> :returningList <> :groupClause <> :groupingSets <> :havingQual <> :windowClause <> :distinctClause <> :sortClause <> :limitOffset <> :limitCount <> :rowMarks <> :setOperations <> :constraintDeps <> :stmt_location 0 :stmt_len 0}
               Original costs: cost=10017.10..10031.60 rows=200 width=64; cost=18791.50..18797.00 rows=200 width=64; cost=64708.22..74029.84 rows=200 width=64
         ->  Custom Scan (MVRewriteScan)  (cost=0.00..28.00 rows=1200 width=64)
               Output: test_1.key, ((count(test_1.value))::text)
               Rewritten SQL: {QUERY :commandType 1 :querySource 0 :canSetTag false :utilityStmt <> :resultRelation 0 :hasAggs false :hasWindowFuncs false :hasTargetSRFs false :hasSubLinks false :hasDistinctOn false :hasRecursive false :hasModifyingCTE false :hasForUpdate false :hasRowSecurity false :cteList <> :rtable ({RTE :alias <> :eref {ALIAS :aliasname test_mv1 :colnames ("key" "count")} :rtekind 0 :relid 16398 :relkind m :tablesample <> :lateral false :inh false :inFromCl true :requiredPerms 2 :checkAsUser 0 :selectedCols (b) :insertedCols (b) :updatedCols (b) :securityQuals <>}) :jointree {FROMEXPR :fromlist ({RANGETBLREF :rtindex 1}) :quals <>} :targetList ({TARGETENTRY :expr {VAR :varno 1 :varattno 1 :vartype 25 :vartypmod -1 :varcollid 100 :varlevelsup 0 :varnoold 1 :varoattno 1 :location -1} :resno 1 :resname <> :ressortgroupref 0 :resorigtbl 0 :resorigcol 0 :resjunk false} {TARGETENTRY :expr {COERCEVIAIO :arg {VAR :varno 1 :varattno 2 :vartype 20 :vartypmod -1 :varcollid 0 :varlevelsup 0 :varnoold 1 :varoattno 2 :location -1} :resulttype 25 :resultcollid 100 :coerceformat 1 :location 582} :resno 2 :resname <> :ressortgroupref 0 :resorigtbl 0 :resorigcol 0 :resjunk false}) :override 0 :onConflict <> :returningList <> :groupClause <> :groupingSets <> :havingQual <> :windowClause <> :distinctClause <> :sortClause <> :limitOffset <> :limitCount <> :rowMarks <> :setOperations <> :constraintDeps <> :stmt_location 0 :stmt_len 0}
               Original costs: cost=10017.10..10023.10 rows=200 width=64; cost=12580.75..12583.75 rows=200 width=64; cost=64708.22..67816.59 rows=200 width=64
(12 rows)

